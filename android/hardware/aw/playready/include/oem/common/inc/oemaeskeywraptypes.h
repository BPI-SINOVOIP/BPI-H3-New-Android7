/**@@@+++@@@@******************************************************************
**
** Microsoft (r) PlayReady (r)
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMAESKEYWRAPTYPES_H__
#define __DRMAESKEYWRAPTYPES_H__

#include <oemaeskey.h>
#include <oemeccp256.h>

ENTER_PK_NAMESPACE;

#define OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES 8

/* to introduce randomness in wrapping output */
#define OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES

/* we accomodate 8 bytes of randomness in the unwrapped keys: this is to make two encryptions of the same value nondeterministic */
#define OEM_AESKEYWRAP_UNWRAPPED_KEY_AES_128_SIZE_IN_DWORDS ( ( DRM_AES_KEYSIZE_128                                               + OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
#define OEM_AESKEYWRAP_WRAPPED_KEY_AES_128_SIZE_IN_DWORDS   ( ( DRM_AES_KEYSIZE_128            + OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES + OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
#define OEM_AESKEYWRAP_UNWRAPPED_KEY_ECC_256_SIZE_IN_DWORDS ( ( ECC_P256_PRIVKEY_SIZE_IN_BYTES                                    + OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
#define OEM_AESKEYWRAP_WRAPPED_KEY_ECC_256_SIZE_IN_DWORDS   ( ( ECC_P256_PRIVKEY_SIZE_IN_BYTES + OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES + OEM_AESKEYWRAP_RANDOMLEN_IN_BYTES ) / sizeof(DRM_DWORD) )

typedef struct __tagOEM_UNWRAPPED_KEY_AES_128
{
    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_UNWRAPPED_KEY_AES_128_SIZE_IN_DWORDS];
} OEM_UNWRAPPED_KEY_AES_128;

typedef struct __tagOEM_WRAPPED_KEY_AES_128
{
    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_WRAPPED_KEY_AES_128_SIZE_IN_DWORDS];
} OEM_WRAPPED_KEY_AES_128;

typedef struct __tagOEM_UNWRAPPED_KEY_ECC_256
{
    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_UNWRAPPED_KEY_ECC_256_SIZE_IN_DWORDS];
} OEM_UNWRAPPED_KEY_ECC_256;

typedef struct __tagOEM_WRAPPED_KEY_ECC_256
{
    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_WRAPPED_KEY_ECC_256_SIZE_IN_DWORDS];
} OEM_WRAPPED_KEY_ECC_256;

#define OEM_AESKEYWRAP_UNWRAPPED_KEY_AES_128_ONLY_SIZE_IN_DWORDS ( ( DRM_AES_KEYSIZE_128                                               ) / sizeof(DRM_DWORD) )
#define OEM_AESKEYWRAP_WRAPPED_KEY_AES_128_ONLY_SIZE_IN_DWORDS   ( ( DRM_AES_KEYSIZE_128            + OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES ) / sizeof(DRM_DWORD) )
#define OEM_AESKEYWRAP_UNWRAPPED_KEY_ECC_256_ONLY_SIZE_IN_DWORDS ( ( ECC_P256_PRIVKEY_SIZE_IN_BYTES                                    ) / sizeof(DRM_DWORD) )
#define OEM_AESKEYWRAP_WRAPPED_KEY_ECC_256_ONLY_SIZE_IN_DWORDS   ( ( ECC_P256_PRIVKEY_SIZE_IN_BYTES + OEM_AESKEYWRAP_BLOCKLEN_IN_BYTES ) / sizeof(DRM_DWORD) )

typedef struct __tagOEM_UNWRAPPED_KEY_AES_128_ONLY
{
    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_UNWRAPPED_KEY_AES_128_ONLY_SIZE_IN_DWORDS];
} OEM_UNWRAPPED_KEY_AES_128_ONLY;

typedef struct __tagOEM_WRAPPED_KEY_AES_128_ONLY
{
    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_WRAPPED_KEY_AES_128_ONLY_SIZE_IN_DWORDS];
} OEM_WRAPPED_KEY_AES_128_ONLY;

typedef struct __tagOEM_UNWRAPPED_KEY_ECC_256_ONLY
{
    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_UNWRAPPED_KEY_ECC_256_ONLY_SIZE_IN_DWORDS];
} OEM_UNWRAPPED_KEY_ECC_256_ONLY;

typedef struct __tagOEM_WRAPPED_KEY_ECC_256_ONLY
{
    DRM_DWORD m_rgdw[OEM_AESKEYWRAP_WRAPPED_KEY_ECC_256_ONLY_SIZE_IN_DWORDS];
} OEM_WRAPPED_KEY_ECC_256_ONLY;

EXIT_PK_NAMESPACE;

#endif /* __DRMAESKEYWRAPTYPES_H__ */
